{
  "version": 3,
  "sources": ["../../@langchain/core/dist/prompts/base.js", "../../@langchain/core/dist/prompts/string.js", "../../mustache/mustache.mjs", "../../@langchain/core/dist/prompts/template.js", "../../@langchain/core/dist/prompts/prompt.js"],
  "sourcesContent": ["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { Runnable } from \"../runnables/base.js\";\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport class BasePromptTemplate extends Runnable {\n    get lc_attributes() {\n        return {\n            partialVariables: undefined, // python doesn't support this yet\n        };\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"prompts\", this._getPromptType()]\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"partialVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Metadata to be used for tracing.\n         */\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Tags to be used for tracing. */\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const { inputVariables } = input;\n        if (inputVariables.includes(\"stop\")) {\n            throw new Error(\"Cannot have an input variable named 'stop', as it is used internally, please rename.\");\n        }\n        Object.assign(this, input);\n    }\n    /**\n     * Merges partial variables and user variables.\n     * @param userVariables The user variables to merge with the partial variables.\n     * @returns A Promise that resolves to an object containing the merged variables.\n     */\n    async mergePartialAndUserVariables(userVariables) {\n        const partialVariables = this.partialVariables ?? {};\n        const partialValues = {};\n        for (const [key, value] of Object.entries(partialVariables)) {\n            if (typeof value === \"string\") {\n                partialValues[key] = value;\n            }\n            else {\n                partialValues[key] = await value();\n            }\n        }\n        const allKwargs = {\n            ...partialValues,\n            ...userVariables,\n        };\n        return allKwargs;\n    }\n    /**\n     * Invokes the prompt template with the given input and options.\n     * @param input The input to invoke the prompt template with.\n     * @param options Optional configuration for the callback.\n     * @returns A Promise that resolves to the output of the prompt template.\n     */\n    async invoke(input, options) {\n        const metadata = {\n            ...this.metadata,\n            ...options?.metadata,\n        };\n        const tags = [...(this.tags ?? []), ...(options?.tags ?? [])];\n        return this._callWithConfig((input) => this.formatPromptValue(input), input, { ...options, tags, metadata, runType: \"prompt\" });\n    }\n    /**\n     * Return a json-like object representing this prompt template.\n     * @deprecated\n     */\n    serialize() {\n        throw new Error(\"Use .toJSON() instead\");\n    }\n    /**\n     * @deprecated\n     * Load a prompt template from a json-like object describing it.\n     *\n     * @remarks\n     * Deserializing needs to be async because templates (e.g. {@link FewShotPromptTemplate}) can\n     * reference remote resources that we read asynchronously with a web\n     * request.\n     */\n    static async deserialize(data) {\n        switch (data._type) {\n            case \"prompt\": {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize(data);\n            }\n            case undefined: {\n                const { PromptTemplate } = await import(\"./prompt.js\");\n                return PromptTemplate.deserialize({ ...data, _type: \"prompt\" });\n            }\n            case \"few_shot\": {\n                const { FewShotPromptTemplate } = await import(\"./few_shot.js\");\n                return FewShotPromptTemplate.deserialize(data);\n            }\n            default:\n                throw new Error(`Invalid prompt type in config: ${data._type}`);\n        }\n    }\n}\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { StringPromptValue, } from \"../prompt_values.js\";\nimport { BasePromptTemplate } from \"./base.js\";\n/**\n * Base class for string prompt templates. It extends the\n * BasePromptTemplate class and overrides the formatPromptValue method to\n * return a StringPromptValue.\n */\nexport class BaseStringPromptTemplate extends BasePromptTemplate {\n    /**\n     * Formats the prompt given the input values and returns a formatted\n     * prompt value.\n     * @param values The input values to format the prompt.\n     * @returns A Promise that resolves to a formatted prompt value.\n     */\n    async formatPromptValue(values) {\n        const formattedPrompt = await this.format(values);\n        return new StringPromptValue(formattedPrompt);\n    }\n}\n", "/*!\r\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\r\n * http://github.com/janl/mustache.js\r\n */\r\n\r\nvar objectToString = Object.prototype.toString;\r\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\r\n  return objectToString.call(object) === '[object Array]';\r\n};\r\n\r\nfunction isFunction (object) {\r\n  return typeof object === 'function';\r\n}\r\n\r\n/**\r\n * More correct typeof string handling array\r\n * which normally returns typeof 'object'\r\n */\r\nfunction typeStr (obj) {\r\n  return isArray(obj) ? 'array' : typeof obj;\r\n}\r\n\r\nfunction escapeRegExp (string) {\r\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\r\n}\r\n\r\n/**\r\n * Null safe way of checking whether or not an object,\r\n * including its prototype, has a given property\r\n */\r\nfunction hasProperty (obj, propName) {\r\n  return obj != null && typeof obj === 'object' && (propName in obj);\r\n}\r\n\r\n/**\r\n * Safe way of detecting whether or not the given thing is a primitive and\r\n * whether it has the given property\r\n */\r\nfunction primitiveHasOwnProperty (primitive, propName) {\r\n  return (\r\n    primitive != null\r\n    && typeof primitive !== 'object'\r\n    && primitive.hasOwnProperty\r\n    && primitive.hasOwnProperty(propName)\r\n  );\r\n}\r\n\r\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\r\n// See https://github.com/janl/mustache.js/issues/189\r\nvar regExpTest = RegExp.prototype.test;\r\nfunction testRegExp (re, string) {\r\n  return regExpTest.call(re, string);\r\n}\r\n\r\nvar nonSpaceRe = /\\S/;\r\nfunction isWhitespace (string) {\r\n  return !testRegExp(nonSpaceRe, string);\r\n}\r\n\r\nvar entityMap = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;',\r\n  '/': '&#x2F;',\r\n  '`': '&#x60;',\r\n  '=': '&#x3D;'\r\n};\r\n\r\nfunction escapeHtml (string) {\r\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\r\n    return entityMap[s];\r\n  });\r\n}\r\n\r\nvar whiteRe = /\\s*/;\r\nvar spaceRe = /\\s+/;\r\nvar equalsRe = /\\s*=/;\r\nvar curlyRe = /\\s*\\}/;\r\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\r\n\r\n/**\r\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\r\n * argument is given here it must be an array with two string values: the\r\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\r\n * course, the default is to use mustaches (i.e. mustache.tags).\r\n *\r\n * A token is an array with at least 4 elements. The first element is the\r\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\r\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\r\n * all text that appears outside a symbol this element is \"text\".\r\n *\r\n * The second element of a token is its \"value\". For mustache tags this is\r\n * whatever else was inside the tag besides the opening symbol. For text tokens\r\n * this is the text itself.\r\n *\r\n * The third and fourth elements of the token are the start and end indices,\r\n * respectively, of the token in the original template.\r\n *\r\n * Tokens that are the root node of a subtree contain two more elements: 1) an\r\n * array of tokens in the subtree and 2) the index in the original template at\r\n * which the closing tag for that section begins.\r\n *\r\n * Tokens for partials also contain two more elements: 1) a string value of\r\n * indendation prior to that tag and 2) the index of that tag on that line -\r\n * eg a value of 2 indicates the partial is the third tag on this line.\r\n */\r\nfunction parseTemplate (template, tags) {\r\n  if (!template)\r\n    return [];\r\n  var lineHasNonSpace = false;\r\n  var sections = [];     // Stack to hold section tokens\r\n  var tokens = [];       // Buffer to hold the tokens\r\n  var spaces = [];       // Indices of whitespace tokens on the current line\r\n  var hasTag = false;    // Is there a {{tag}} on the current line?\r\n  var nonSpace = false;  // Is there a non-space char on the current line?\r\n  var indentation = '';  // Tracks indentation for tags that use it\r\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\r\n\r\n  // Strips all whitespace tokens array for the current line\r\n  // if there was a {{#tag}} on it and otherwise only space.\r\n  function stripSpace () {\r\n    if (hasTag && !nonSpace) {\r\n      while (spaces.length)\r\n        delete tokens[spaces.pop()];\r\n    } else {\r\n      spaces = [];\r\n    }\r\n\r\n    hasTag = false;\r\n    nonSpace = false;\r\n  }\r\n\r\n  var openingTagRe, closingTagRe, closingCurlyRe;\r\n  function compileTags (tagsToCompile) {\r\n    if (typeof tagsToCompile === 'string')\r\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\r\n\r\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\r\n      throw new Error('Invalid tags: ' + tagsToCompile);\r\n\r\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\r\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\r\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\r\n  }\r\n\r\n  compileTags(tags || mustache.tags);\r\n\r\n  var scanner = new Scanner(template);\r\n\r\n  var start, type, value, chr, token, openSection;\r\n  while (!scanner.eos()) {\r\n    start = scanner.pos;\r\n\r\n    // Match any text between tags.\r\n    value = scanner.scanUntil(openingTagRe);\r\n\r\n    if (value) {\r\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\r\n        chr = value.charAt(i);\r\n\r\n        if (isWhitespace(chr)) {\r\n          spaces.push(tokens.length);\r\n          indentation += chr;\r\n        } else {\r\n          nonSpace = true;\r\n          lineHasNonSpace = true;\r\n          indentation += ' ';\r\n        }\r\n\r\n        tokens.push([ 'text', chr, start, start + 1 ]);\r\n        start += 1;\r\n\r\n        // Check for whitespace on the current line.\r\n        if (chr === '\\n') {\r\n          stripSpace();\r\n          indentation = '';\r\n          tagIndex = 0;\r\n          lineHasNonSpace = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Match the opening tag.\r\n    if (!scanner.scan(openingTagRe))\r\n      break;\r\n\r\n    hasTag = true;\r\n\r\n    // Get the tag type.\r\n    type = scanner.scan(tagRe) || 'name';\r\n    scanner.scan(whiteRe);\r\n\r\n    // Get the tag value.\r\n    if (type === '=') {\r\n      value = scanner.scanUntil(equalsRe);\r\n      scanner.scan(equalsRe);\r\n      scanner.scanUntil(closingTagRe);\r\n    } else if (type === '{') {\r\n      value = scanner.scanUntil(closingCurlyRe);\r\n      scanner.scan(curlyRe);\r\n      scanner.scanUntil(closingTagRe);\r\n      type = '&';\r\n    } else {\r\n      value = scanner.scanUntil(closingTagRe);\r\n    }\r\n\r\n    // Match the closing tag.\r\n    if (!scanner.scan(closingTagRe))\r\n      throw new Error('Unclosed tag at ' + scanner.pos);\r\n\r\n    if (type == '>') {\r\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\r\n    } else {\r\n      token = [ type, value, start, scanner.pos ];\r\n    }\r\n    tagIndex++;\r\n    tokens.push(token);\r\n\r\n    if (type === '#' || type === '^') {\r\n      sections.push(token);\r\n    } else if (type === '/') {\r\n      // Check section nesting.\r\n      openSection = sections.pop();\r\n\r\n      if (!openSection)\r\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\r\n\r\n      if (openSection[1] !== value)\r\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\r\n    } else if (type === 'name' || type === '{' || type === '&') {\r\n      nonSpace = true;\r\n    } else if (type === '=') {\r\n      // Set the tags for the next time around.\r\n      compileTags(value);\r\n    }\r\n  }\r\n\r\n  stripSpace();\r\n\r\n  // Make sure there are no open sections when we're done.\r\n  openSection = sections.pop();\r\n\r\n  if (openSection)\r\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\r\n\r\n  return nestTokens(squashTokens(tokens));\r\n}\r\n\r\n/**\r\n * Combines the values of consecutive text tokens in the given `tokens` array\r\n * to a single token.\r\n */\r\nfunction squashTokens (tokens) {\r\n  var squashedTokens = [];\r\n\r\n  var token, lastToken;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    if (token) {\r\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\r\n        lastToken[1] += token[1];\r\n        lastToken[3] = token[3];\r\n      } else {\r\n        squashedTokens.push(token);\r\n        lastToken = token;\r\n      }\r\n    }\r\n  }\r\n\r\n  return squashedTokens;\r\n}\r\n\r\n/**\r\n * Forms the given array of `tokens` into a nested tree structure where\r\n * tokens that represent a section have two additional items: 1) an array of\r\n * all tokens that appear in that section and 2) the index in the original\r\n * template that represents the end of that section.\r\n */\r\nfunction nestTokens (tokens) {\r\n  var nestedTokens = [];\r\n  var collector = nestedTokens;\r\n  var sections = [];\r\n\r\n  var token, section;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    switch (token[0]) {\r\n      case '#':\r\n      case '^':\r\n        collector.push(token);\r\n        sections.push(token);\r\n        collector = token[4] = [];\r\n        break;\r\n      case '/':\r\n        section = sections.pop();\r\n        section[5] = token[2];\r\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\r\n        break;\r\n      default:\r\n        collector.push(token);\r\n    }\r\n  }\r\n\r\n  return nestedTokens;\r\n}\r\n\r\n/**\r\n * A simple string scanner that is used by the template parser to find\r\n * tokens in template strings.\r\n */\r\nfunction Scanner (string) {\r\n  this.string = string;\r\n  this.tail = string;\r\n  this.pos = 0;\r\n}\r\n\r\n/**\r\n * Returns `true` if the tail is empty (end of string).\r\n */\r\nScanner.prototype.eos = function eos () {\r\n  return this.tail === '';\r\n};\r\n\r\n/**\r\n * Tries to match the given regular expression at the current position.\r\n * Returns the matched text if it can match, the empty string otherwise.\r\n */\r\nScanner.prototype.scan = function scan (re) {\r\n  var match = this.tail.match(re);\r\n\r\n  if (!match || match.index !== 0)\r\n    return '';\r\n\r\n  var string = match[0];\r\n\r\n  this.tail = this.tail.substring(string.length);\r\n  this.pos += string.length;\r\n\r\n  return string;\r\n};\r\n\r\n/**\r\n * Skips all text until the given regular expression can be matched. Returns\r\n * the skipped string, which is the entire tail if no match can be made.\r\n */\r\nScanner.prototype.scanUntil = function scanUntil (re) {\r\n  var index = this.tail.search(re), match;\r\n\r\n  switch (index) {\r\n    case -1:\r\n      match = this.tail;\r\n      this.tail = '';\r\n      break;\r\n    case 0:\r\n      match = '';\r\n      break;\r\n    default:\r\n      match = this.tail.substring(0, index);\r\n      this.tail = this.tail.substring(index);\r\n  }\r\n\r\n  this.pos += match.length;\r\n\r\n  return match;\r\n};\r\n\r\n/**\r\n * Represents a rendering context by wrapping a view object and\r\n * maintaining a reference to the parent context.\r\n */\r\nfunction Context (view, parentContext) {\r\n  this.view = view;\r\n  this.cache = { '.': this.view };\r\n  this.parent = parentContext;\r\n}\r\n\r\n/**\r\n * Creates a new context using the given view with this context\r\n * as the parent.\r\n */\r\nContext.prototype.push = function push (view) {\r\n  return new Context(view, this);\r\n};\r\n\r\n/**\r\n * Returns the value of the given name in this context, traversing\r\n * up the context hierarchy if the value is absent in this context's view.\r\n */\r\nContext.prototype.lookup = function lookup (name) {\r\n  var cache = this.cache;\r\n\r\n  var value;\r\n  if (cache.hasOwnProperty(name)) {\r\n    value = cache[name];\r\n  } else {\r\n    var context = this, intermediateValue, names, index, lookupHit = false;\r\n\r\n    while (context) {\r\n      if (name.indexOf('.') > 0) {\r\n        intermediateValue = context.view;\r\n        names = name.split('.');\r\n        index = 0;\r\n\r\n        /**\r\n         * Using the dot notion path in `name`, we descend through the\r\n         * nested objects.\r\n         *\r\n         * To be certain that the lookup has been successful, we have to\r\n         * check if the last object in the path actually has the property\r\n         * we are looking for. We store the result in `lookupHit`.\r\n         *\r\n         * This is specially necessary for when the value has been set to\r\n         * `undefined` and we want to avoid looking up parent contexts.\r\n         *\r\n         * In the case where dot notation is used, we consider the lookup\r\n         * to be successful even if the last \"object\" in the path is\r\n         * not actually an object but a primitive (e.g., a string, or an\r\n         * integer), because it is sometimes useful to access a property\r\n         * of an autoboxed primitive, such as the length of a string.\r\n         **/\r\n        while (intermediateValue != null && index < names.length) {\r\n          if (index === names.length - 1)\r\n            lookupHit = (\r\n              hasProperty(intermediateValue, names[index])\r\n              || primitiveHasOwnProperty(intermediateValue, names[index])\r\n            );\r\n\r\n          intermediateValue = intermediateValue[names[index++]];\r\n        }\r\n      } else {\r\n        intermediateValue = context.view[name];\r\n\r\n        /**\r\n         * Only checking against `hasProperty`, which always returns `false` if\r\n         * `context.view` is not an object. Deliberately omitting the check\r\n         * against `primitiveHasOwnProperty` if dot notation is not used.\r\n         *\r\n         * Consider this example:\r\n         * ```\r\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\r\n         * ```\r\n         *\r\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\r\n         * in the dot notation case, then render call would return:\r\n         *\r\n         * \"The length of a football field is 9.\"\r\n         *\r\n         * rather than the expected:\r\n         *\r\n         * \"The length of a football field is 100 yards.\"\r\n         **/\r\n        lookupHit = hasProperty(context.view, name);\r\n      }\r\n\r\n      if (lookupHit) {\r\n        value = intermediateValue;\r\n        break;\r\n      }\r\n\r\n      context = context.parent;\r\n    }\r\n\r\n    cache[name] = value;\r\n  }\r\n\r\n  if (isFunction(value))\r\n    value = value.call(this.view);\r\n\r\n  return value;\r\n};\r\n\r\n/**\r\n * A Writer knows how to take a stream of tokens and render them to a\r\n * string, given a context. It also maintains a cache of templates to\r\n * avoid the need to parse the same template twice.\r\n */\r\nfunction Writer () {\r\n  this.templateCache = {\r\n    _cache: {},\r\n    set: function set (key, value) {\r\n      this._cache[key] = value;\r\n    },\r\n    get: function get (key) {\r\n      return this._cache[key];\r\n    },\r\n    clear: function clear () {\r\n      this._cache = {};\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Clears all cached templates in this writer.\r\n */\r\nWriter.prototype.clearCache = function clearCache () {\r\n  if (typeof this.templateCache !== 'undefined') {\r\n    this.templateCache.clear();\r\n  }\r\n};\r\n\r\n/**\r\n * Parses and caches the given `template` according to the given `tags` or\r\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\r\n * that is generated from the parse.\r\n */\r\nWriter.prototype.parse = function parse (template, tags) {\r\n  var cache = this.templateCache;\r\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\r\n  var isCacheEnabled = typeof cache !== 'undefined';\r\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\r\n\r\n  if (tokens == undefined) {\r\n    tokens = parseTemplate(template, tags);\r\n    isCacheEnabled && cache.set(cacheKey, tokens);\r\n  }\r\n  return tokens;\r\n};\r\n\r\n/**\r\n * High-level method that is used to render the given `template` with\r\n * the given `view`.\r\n *\r\n * The optional `partials` argument may be an object that contains the\r\n * names and templates of partials that are used in the template. It may\r\n * also be a function that is used to load partial templates on the fly\r\n * that takes a single argument: the name of the partial.\r\n *\r\n * If the optional `config` argument is given here, then it should be an\r\n * object with a `tags` attribute or an `escape` attribute or both.\r\n * If an array is passed, then it will be interpreted the same way as\r\n * a `tags` attribute on a `config` object.\r\n *\r\n * The `tags` attribute of a `config` object must be an array with two\r\n * string values: the opening and closing tags used in the template (e.g.\r\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\r\n *\r\n * The `escape` attribute of a `config` object must be a function which\r\n * accepts a string as input and outputs a safely escaped string.\r\n * If an `escape` function is not provided, then an HTML-safe string\r\n * escaping function is used as the default.\r\n */\r\nWriter.prototype.render = function render (template, view, partials, config) {\r\n  var tags = this.getConfigTags(config);\r\n  var tokens = this.parse(template, tags);\r\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\r\n  return this.renderTokens(tokens, context, partials, template, config);\r\n};\r\n\r\n/**\r\n * Low-level method that renders the given array of `tokens` using\r\n * the given `context` and `partials`.\r\n *\r\n * Note: The `originalTemplate` is only ever used to extract the portion\r\n * of the original template that was contained in a higher-order section.\r\n * If the template doesn't use higher-order sections, this argument may\r\n * be omitted.\r\n */\r\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\r\n  var buffer = '';\r\n\r\n  var token, symbol, value;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    value = undefined;\r\n    token = tokens[i];\r\n    symbol = token[0];\r\n\r\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\r\n    else if (symbol === '&') value = this.unescapedValue(token, context);\r\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\r\n    else if (symbol === 'text') value = this.rawValue(token);\r\n\r\n    if (value !== undefined)\r\n      buffer += value;\r\n  }\r\n\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\r\n  var self = this;\r\n  var buffer = '';\r\n  var value = context.lookup(token[1]);\r\n\r\n  // This function is used to render an arbitrary template\r\n  // in the current context by higher-order sections.\r\n  function subRender (template) {\r\n    return self.render(template, context, partials, config);\r\n  }\r\n\r\n  if (!value) return;\r\n\r\n  if (isArray(value)) {\r\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\r\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\r\n    }\r\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\r\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\r\n  } else if (isFunction(value)) {\r\n    if (typeof originalTemplate !== 'string')\r\n      throw new Error('Cannot use higher-order sections without the original template');\r\n\r\n    // Extract the portion of the original template that the section contains.\r\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\r\n\r\n    if (value != null)\r\n      buffer += value;\r\n  } else {\r\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n  }\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\r\n  var value = context.lookup(token[1]);\r\n\r\n  // Use JavaScript's definition of falsy. Include empty arrays.\r\n  // See https://github.com/janl/mustache.js/issues/186\r\n  if (!value || (isArray(value) && value.length === 0))\r\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n};\r\n\r\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\r\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\r\n  var partialByNl = partial.split('\\n');\r\n  for (var i = 0; i < partialByNl.length; i++) {\r\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\r\n      partialByNl[i] = filteredIndentation + partialByNl[i];\r\n    }\r\n  }\r\n  return partialByNl.join('\\n');\r\n};\r\n\r\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\r\n  if (!partials) return;\r\n  var tags = this.getConfigTags(config);\r\n\r\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\r\n  if (value != null) {\r\n    var lineHasNonSpace = token[6];\r\n    var tagIndex = token[5];\r\n    var indentation = token[4];\r\n    var indentedValue = value;\r\n    if (tagIndex == 0 && indentation) {\r\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\r\n    }\r\n    var tokens = this.parse(indentedValue, tags);\r\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\r\n  }\r\n};\r\n\r\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return value;\r\n};\r\n\r\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\r\n  var escape = this.getConfigEscape(config) || mustache.escape;\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\r\n};\r\n\r\nWriter.prototype.rawValue = function rawValue (token) {\r\n  return token[1];\r\n};\r\n\r\nWriter.prototype.getConfigTags = function getConfigTags (config) {\r\n  if (isArray(config)) {\r\n    return config;\r\n  }\r\n  else if (config && typeof config === 'object') {\r\n    return config.tags;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\r\n  if (config && typeof config === 'object' && !isArray(config)) {\r\n    return config.escape;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nvar mustache = {\r\n  name: 'mustache.js',\r\n  version: '4.2.0',\r\n  tags: [ '{{', '}}' ],\r\n  clearCache: undefined,\r\n  escape: undefined,\r\n  parse: undefined,\r\n  render: undefined,\r\n  Scanner: undefined,\r\n  Context: undefined,\r\n  Writer: undefined,\r\n  /**\r\n   * Allows a user to override the default caching strategy, by providing an\r\n   * object with set, get and clear methods. This can also be used to disable\r\n   * the cache by setting it to the literal `undefined`.\r\n   */\r\n  set templateCache (cache) {\r\n    defaultWriter.templateCache = cache;\r\n  },\r\n  /**\r\n   * Gets the default or overridden caching object from the default writer.\r\n   */\r\n  get templateCache () {\r\n    return defaultWriter.templateCache;\r\n  }\r\n};\r\n\r\n// All high-level mustache.* functions use this writer.\r\nvar defaultWriter = new Writer();\r\n\r\n/**\r\n * Clears all cached templates in the default writer.\r\n */\r\nmustache.clearCache = function clearCache () {\r\n  return defaultWriter.clearCache();\r\n};\r\n\r\n/**\r\n * Parses and caches the given template in the default writer and returns the\r\n * array of tokens it contains. Doing this ahead of time avoids the need to\r\n * parse templates on the fly as they are rendered.\r\n */\r\nmustache.parse = function parse (template, tags) {\r\n  return defaultWriter.parse(template, tags);\r\n};\r\n\r\n/**\r\n * Renders the `template` with the given `view`, `partials`, and `config`\r\n * using the default writer.\r\n */\r\nmustache.render = function render (template, view, partials, config) {\r\n  if (typeof template !== 'string') {\r\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\r\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\r\n                        'argument for mustache#render(template, view, partials)');\r\n  }\r\n\r\n  return defaultWriter.render(template, view, partials, config);\r\n};\r\n\r\n// Export the escaping function so that the user may override it.\r\n// See https://github.com/janl/mustache.js/issues/244\r\nmustache.escape = escapeHtml;\r\n\r\n// Export these mainly for testing, but also for advanced usage.\r\nmustache.Scanner = Scanner;\r\nmustache.Context = Context;\r\nmustache.Writer = Writer;\r\n\r\nexport default mustache;\r\n", "import mustache from \"mustache\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nfunction configureMustache() {\n    // Use unescaped HTML\n    // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n    mustache.escape = (text) => text;\n}\nexport const parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (template) => template.map((temp) => {\n    if (temp[0] === \"name\") {\n        const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n        return { type: \"variable\", name };\n    }\n    else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n        // # represents a section, \"&\" represents an unescaped variable.\n        // These should both be considered variables.\n        return { type: \"variable\", name: temp[1] };\n    }\n    else {\n        return { type: \"literal\", text: temp[1] };\n    }\n});\nexport const parseMustache = (template) => {\n    configureMustache();\n    const parsed = mustache.parse(template);\n    return mustacheTemplateToNodes(parsed);\n};\nexport const interpolateFString = (template, values) => {\n    return parseFString(template).reduce((res, node) => {\n        if (node.type === \"variable\") {\n            if (node.name in values) {\n                const stringValue = typeof values[node.name] === \"string\"\n                    ? values[node.name]\n                    : JSON.stringify(values[node.name]);\n                return res + stringValue;\n            }\n            throw new Error(`(f-string) Missing value for input ${node.name}`);\n        }\n        return res + node.text;\n    }, \"\");\n};\nexport const interpolateMustache = (template, values) => {\n    configureMustache();\n    return mustache.render(template, values);\n};\nexport const DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n    mustache: interpolateMustache,\n};\nexport const DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n    mustache: parseMustache,\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => {\n    try {\n        return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n    }\n    catch (e) {\n        const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n        throw error;\n    }\n};\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        if (Array.isArray(template)) {\n            template.forEach((message) => {\n                if (message.type === \"text\") {\n                    renderTemplate(message.text, templateFormat, dummyInputs);\n                }\n                else if (message.type === \"image_url\") {\n                    if (typeof message.image_url === \"string\") {\n                        renderTemplate(message.image_url, templateFormat, dummyInputs);\n                    }\n                    else {\n                        const imageUrl = message.image_url.url;\n                        renderTemplate(imageUrl, templateFormat, dummyInputs);\n                    }\n                }\n                else {\n                    throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);\n                }\n            });\n        }\n        else {\n            renderTemplate(template, templateFormat, dummyInputs);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n", "// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Additional fields which should be included inside\n         * the message content array if using a complex message\n         * content.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"additionalContentFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If input is mustache and validateTemplate is not defined, set it to false\n        if (input.templateFormat === \"mustache\" &&\n            input.validateTemplate === undefined) {\n            this.validateTemplate = false;\n        }\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            if (this.templateFormat === \"mustache\") {\n                throw new Error(\"Mustache templates cannot be validated.\");\n            }\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    static fromTemplate(template, options) {\n        const { templateFormat = \"f-string\", ...rest } = options ?? {};\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n"],
  "mappings": "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",
  "names": ["input", "PromptTemplate", "clearCache", "parse", "render", "i", "parseTemplate", "parseTemplate"]
}
